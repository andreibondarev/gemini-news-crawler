# [NewsFiler v2] NewsPaper: Google Cloud Blog (this should go in the Entries as of v2)
# [NewsFiler v2] GUID: https://cloud.google.com/blog/products/serverless/introducing-cloud-run-volume-mounts/
# [NewsFiler v2] entries.keys: ["title", "url", "summary", "author", "categories", "published", "entry_id", "image"]
--- !ruby/object:Feedjira::Parser::RSSEntry
title: 'Introducing Cloud Run volume mounts: connect your app to Cloud Storage or
  NFS'
url: https://cloud.google.com/blog/products/serverless/introducing-cloud-run-volume-mounts/
summary: "<div class=\"block-paragraph\"><p data-block-key=\"vdaxa\">We’ve built Cloud
  Run, a fully managed container platform, directly on top of Google’s scalable infrastructure
  to simplify developers’ lives and make it easier to build cloud-native applications.</p><p
  data-block-key=\"4g466\">As it stands, each Cloud Run instance has access to its
  own local file system. But what if you have an existing application that expects
  to access <b>shared</b> data stored in a local file system? Without a straightforward
  way to mount storage systems like file servers or Cloud Storage buckets, developers
  had to use complex solutions or look to other services. Today, we’re excited to
  launch a new feature in preview: volume mounts.</p><p data-block-key=\"c3l6u\">With
  volume mounts, mounting a volume in a Cloud Run service or job is a single command.
  You can mount a Cloud Storage bucket or an NFS share, like a Cloud Filestore instance.
  This allows your container to seamlessly access the storage bucket or file server
  content as if the files were local, utilizing file system semantics for a familiar
  experience.</p><p data-block-key=\"bnqv2\">You can mount a Cloud Storage bucket
  by updating your Cloud Run service with the following command (you can find more
  details and instructions in the Try it out section below):</p></div>\n<div class=\"block-code\"><dl>\n
  \   <dt>code_block</dt>\n    <dd>&lt;ListValue: [StructValue([(&#x27;code&#x27;,
  &#x27;gcloud beta run services update [SERVICE_NAME] \\\\\\r\\n--execution-environment
  gen2 \\\\ \\r\\n--add-volume=name=v_mount,type=cloud-storage,bucket=[YOUR_BUCKET_NAME]
  \ \\\\\\r\\n--add-volume-mount=volume=v_mount,mount-path=[MOUNT_PATH]&#x27;), (&#x27;language&#x27;,
  &#x27;&#x27;), (&#x27;caption&#x27;, &lt;wagtail.rich_text.RichText object at 0x3ee934a8e370&gt;)])]&gt;</dd>\n</dl></div>\n<div
  class=\"block-paragraph_advanced\"><p><span style=\"vertical-align: baseline;\">Volume
  mounts come in handy in a number of situations. </span></p>\n<h3 role=\"presentation\"><strong
  style=\"vertical-align: baseline;\">1. Store app configuration</strong></h3>\n<p><span
  style=\"vertical-align: baseline;\">Let's consider a scenario where you need to
  add config files to your service. When applications launch, they often need to gather
  information about their environment and load initial settings to determine their
  behavior.</span></p>\n<p><span style=\"vertical-align: baseline;\">In the past,
  we’ve seen customers use </span><a href=\"https://cloud.google.com/security/products/secret-manager\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">Secret Manager</span></a><span
  style=\"vertical-align: baseline;\"> to store and mount this information, but for
  configuration data that doesn’t need to be kept secret, Cloud Storage is a more
  straightforward solution. Simply put all your configuration into a file in your
  preferred format, upload the file to a Cloud Storage bucket, and mount the bucket
  in your Cloud Run service or job at the required path. </span></p>\n<p><span style=\"vertical-align:
  baseline;\">Since Cloud Run supports pulling public container images from Docker
  Hub directly, mounting your own config files to customize official images (like
  Grafana or Nginx) becomes very convenient. There's no need to build, add your config
  files and host your own container image. Just deploy an official container image
  from Docker Hub directly, store your config files in a Cloud Storage bucket and
  mount them where they are expected.</span></p></div>\n<div class=\"block-image_full_width\">\n\n\n\n\n\n\n
  \ \n    <div class=\"article-module h-c-page\">\n      <div class=\"h-c-grid\">\n
  \ \n\n    <figure class=\"article-image--large\n      \n      \n        h-c-grid__col\n
  \       h-c-grid__col--6 h-c-grid__col--offset-3\n        \n        \n      \"\n
  \     >\n\n      \n      \n        \n        <img\n            src=\"https://storage.googleapis.com/gweb-cloudblog-publish/images/1_-_Store_app_configuration.max-1000x1000.png\"\n
  \       \n          alt=\"1 - Store app configuration\">\n        \n        </a>\n
  \     \n    </figure>\n\n  \n      </div>\n    </div>\n  \n\n\n\n\n</div>\n<div
  class=\"block-paragraph_advanced\"><h3 role=\"presentation\"><strong><span style=\"vertical-align:
  baseline;\">2. </span></strong><strong style=\"vertical-align: baseline;\">Event-driven
  Cloud Storage handlers</strong></h3>\n<p><span style=\"vertical-align: baseline;\">Many
  applications are built using an event-driven design pattern. A common use case is
  executing custom code based on a new file being uploaded to a Cloud Storage bucket.
  </span><a href=\"https://cloud.google.com/blog/topics/developers-practitioners/eventarc-unified-eventing-experience-google-cloud\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">EventArc</span></a><span
  style=\"vertical-align: baseline;\"> is a great tool to listen to such events and
  to trigger a Cloud Run service directly. It forwards all relevant event metadata,
  including the file name and location — but not the file itself. Until now, to retrieve
  and process the file, you needed to use the Cloud Storage client SDK to explicitly
  retrieve it. </span></p>\n<p><span style=\"vertical-align: baseline;\">With volume
  mounts you can now mount the relevant bucket directly. This allows you to access
  the file directly via the filesystem, eliminating the need for custom code to fetch
  it.</span></p></div>\n<div class=\"block-image_full_width\">\n\n\n\n\n\n\n  \n    <div
  class=\"article-module h-c-page\">\n      <div class=\"h-c-grid\">\n  \n\n    <figure
  class=\"article-image--large\n      \n      \n        h-c-grid__col\n        h-c-grid__col--6
  h-c-grid__col--offset-3\n        \n        \n      \"\n      >\n\n      \n      \n
  \       \n        <img\n            src=\"https://storage.googleapis.com/gweb-cloudblog-publish/images/2-_Event-driven_Cloud_Storage_handlers.max-1000x1000.png\"\n
  \       \n          alt=\"2- Event-driven Cloud Storage handlers\">\n        \n
  \       </a>\n      \n    </figure>\n\n  \n      </div>\n    </div>\n  \n\n\n\n\n</div>\n<div
  class=\"block-paragraph_advanced\"><h3 role=\"presentation\"><strong style=\"vertical-align:
  baseline;\">3. Load a vector database file</strong></h3>\n<p><span style=\"vertical-align:
  baseline;\">If you have your Langchain application deployed on Cloud Run, you may
  need a vector database, like </span><a href=\"https://www.trychroma.com/\" rel=\"noopener\"
  target=\"_blank\"><span style=\"text-decoration: underline; vertical-align: baseline;\">ChromaDB</span></a><span
  style=\"vertical-align: baseline;\">. Because the indexed documents are constantly
  changing, mounting an NFS storage is a great way to keep your service stateless
  and externalize your ChromaDB collection from the container — all while having a
  dedicated ingestion pipeline for new documents outside your service. </span></p>\n<p><span
  style=\"vertical-align: baseline;\">Persisted ChromaDB collections can grow large
  quickly, so Cloud Filestore is a fast option to access them from all your Cloud
  Run application instances.</span></p></div>\n<div class=\"block-image_full_width\">\n\n\n\n\n\n\n
  \ \n    <div class=\"article-module h-c-page\">\n      <div class=\"h-c-grid\">\n
  \ \n\n    <figure class=\"article-image--large\n      \n      \n        h-c-grid__col\n
  \       h-c-grid__col--6 h-c-grid__col--offset-3\n        \n        \n      \"\n
  \     >\n\n      \n      \n        \n        <img\n            src=\"https://storage.googleapis.com/gweb-cloudblog-publish/images/3_-_Load_a_vector_database.max-1000x1000.png\"\n
  \       \n          alt=\"3 - Load a vector database\">\n        \n        </a>\n
  \     \n    </figure>\n\n  \n      </div>\n    </div>\n  \n\n\n\n\n</div>\n<div
  class=\"block-paragraph_advanced\"><h3 role=\"presentation\"><strong style=\"vertical-align:
  baseline;\">4. Serve a static website</strong></h3>\n<p><span style=\"vertical-align:
  baseline;\">For simple public-facing file hosting, you could directly use Cloud
  Storage’s </span><a href=\"https://cloud.google.com/storage/docs/hosting-static-website\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">static website hosting
  feature</span></a><span style=\"vertical-align: baseline;\">. However, if you need
  private networking features or a simple login experience via </span><a href=\"https://cloud.google.com/security/products/iap?hl=en\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">Identity-Aware Proxy
  (IAP)</span></a><span style=\"vertical-align: baseline;\">, Cloud Run is an excellent
  choice. </span></p>\n<p><span style=\"vertical-align: baseline;\">Previously, you
  had to copy all the static files into your container image to host and serve them
  from there. However, that required you to rebuild the image and then redeploy your
  service every time you changed the static content. </span></p>\n<p><span style=\"vertical-align:
  baseline;\">With volume mounts, you can now use a standard NGINX web server and
  serve your files from a mounted Cloud Storage bucket. Cloud Run accesses your files
  using standard file system semantics, so you can use the official, publicly hosted
  NGINX container image from DockerHub directly. You can now modify your static assets
  or add new ones as needed, with all changes taking effect for your Cloud Run service
  promptly and without downtime. </span></p>\n<p><span style=\"vertical-align: baseline;\">This
  setup provides access to all the valuable ingress features, including IAP, while
  retaining the flexibility of storing your files in a Cloud Storage bucket.</span></p></div>\n<div
  class=\"block-image_full_width\">\n\n\n\n\n\n\n  \n    <div class=\"article-module
  h-c-page\">\n      <div class=\"h-c-grid\">\n  \n\n    <figure class=\"article-image--large\n
  \     \n      \n        h-c-grid__col\n        h-c-grid__col--6 h-c-grid__col--offset-3\n
  \       \n        \n      \"\n      >\n\n      \n      \n        \n        <img\n
  \           src=\"https://storage.googleapis.com/gweb-cloudblog-publish/images/4_-_Serve_a_static_website.max-1000x1000.png\"\n
  \       \n          alt=\"4 - Serve a static website\">\n        \n        </a>\n
  \     \n    </figure>\n\n  \n      </div>\n    </div>\n  \n\n\n\n\n</div>\n<div
  class=\"block-paragraph_advanced\"><p><span style=\"vertical-align: baseline;\">To
  run a simple web server that serves files from your Cloud Storage bucket, deploy
  the official NGINX image from Docker Hub and mount the bucket to the directory where
  NGINX expects to find static content: '/usr/share/nginx/html'. You can do this with
  a single command: </span></p></div>\n<div class=\"block-code\"><dl>\n    <dt>code_block</dt>\n
  \   <dd>&lt;ListValue: [StructValue([(&#x27;code&#x27;, &quot;gcloud beta run deploy
  --image nginx [SERVICE_NAME] \\\\\\r\\n--execution-environment gen2 --port 80 \\\\\\r\\n--add-volume=name=html-volume,type=cloud-storage,bucket=[YOUR_BUCKET_NAME],readonly=true
  \\\\\\r\\n--add-volume-mount=volume=html-volume,mount-path=&#x27;/usr/share/nginx/html&#x27;&quot;),
  (&#x27;language&#x27;, &#x27;&#x27;), (&#x27;caption&#x27;, &lt;wagtail.rich_text.RichText
  object at 0x3ee934a8e850&gt;)])]&gt;</dd>\n</dl></div>\n<div class=\"block-paragraph_advanced\"><p><span
  style=\"vertical-align: baseline;\">As a last step, be sure to set up content caching,
  either through </span><a href=\"https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/\"
  rel=\"noopener\" target=\"_blank\"><span style=\"text-decoration: underline; vertical-align:
  baseline;\">NGINX content caching</span></a><span style=\"vertical-align: baseline;\">
  or Cloud CDN. Without caching, each request triggers a Cloud Storage get request,
  which can lead to increased costs as well as unnecessary latency for your users.</span></p>\n<h3><strong
  style=\"vertical-align: baseline;\">Try it out</strong></h3>\n<p><span style=\"vertical-align:
  baseline;\">You can mount a Cloud Storage bucket or any NFS file share by </span><a
  href=\"https://cloud.google.com/run/docs/configuring/services/cloud-storage-volume-mounts#mount-volume#command-line\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">using a gcloud command</span></a><span
  style=\"vertical-align: baseline;\">, </span><a href=\"https://cloud.google.com/run/docs/configuring/services/cloud-storage-volume-mounts#yaml\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">updating the Cloud
  Run YAML resource definition</span></a><span style=\"vertical-align: baseline;\">
  or by deploying via </span><a href=\"https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloud_run_v2_service#example-usage---cloudrunv2-service-mount-nfs\"
  rel=\"noopener\" target=\"_blank\"><span style=\"text-decoration: underline; vertical-align:
  baseline;\">Terraform</span></a><span style=\"vertical-align: baseline;\">. </span><span
  style=\"vertical-align: baseline;\">For example, you can perform a source-based
  deployment to a new Cloud Run job and mount a Cloud Storage bucket with the following
  command:</span></p></div>\n<div class=\"block-code\"><dl>\n    <dt>code_block</dt>\n
  \   <dd>&lt;ListValue: [StructValue([(&#x27;code&#x27;, &#x27;gcloud beta run jobs
  deploy [SERVICE_NAME] --source \\\\\\r\\n--execution-environment gen2 \\\\\\r\\n--add-volume=name=[VOLUME_NAME],type=cloud-storage,bucket=[BUCKET_NAME]
  \\\\ \\r\\n--add-volume-mount=volume=[VOLUME_NAME],mount-path=[MOUNT_PATH]&#x27;),
  (&#x27;language&#x27;, &#x27;&#x27;), (&#x27;caption&#x27;, &lt;wagtail.rich_text.RichText
  object at 0x3ee934a8e5b0&gt;)])]&gt;</dd>\n</dl></div>\n<div class=\"block-paragraph_advanced\"><p><span
  style=\"vertical-align: baseline;\">Similarly, you can mount any NFS file share
  as a volume in Cloud Run. If you don’t already have an NFS server, we recommend
  using Cloud Filestore, Google Cloud’s fully managed NFS offering. </span></p>\n<p><span
  style=\"vertical-align: baseline;\">For more information and to get started, take
  a look at our documentation:</span></p>\n<ul>\n<li aria-level=\"1\" style=\"list-style-type:
  disc; vertical-align: baseline;\">\n<p role=\"presentation\"><span style=\"vertical-align:
  baseline;\">Mount a Cloud Storage bucket in a </span><a href=\"https://cloud.google.com/run/docs/configuring/services/cloud-storage-volume-mounts\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">service</span></a><span
  style=\"vertical-align: baseline;\"> or </span><a href=\"https://cloud.google.com/run/docs/configuring/jobs/cloud-storage-volume-mounts\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">job</span></a></p>\n</li>\n<li
  aria-level=\"1\" style=\"list-style-type: disc; vertical-align: baseline;\">\n<p
  role=\"presentation\"><span style=\"vertical-align: baseline;\">Mount an NFS volume
  in a </span><a href=\"http://cloud.google.com/run/docs/configuring/services/nfs-volume-mounts\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">service</span></a><span
  style=\"vertical-align: baseline;\"> or </span><a href=\"http://cloud.google.com/run/docs/configuring/jobs/nfs-volume-mounts\"><span
  style=\"text-decoration: underline; vertical-align: baseline;\">job</span></a></p>\n</li>\n</ul>\n<p><span
  style=\"vertical-align: baseline;\">We’re excited about how easy volume mounts in
  Cloud Run make it to access data, port existing applications, and even to configure
  some pre-built container images. Try this feature in preview today.</span></p></div>"
author: Christoph Stanger
categories:
- Storage & Data Transfer
- Application Modernization
- Serverless
published: 2024-03-22 16:00:00.000000000 Z
entry_id: !ruby/object:Feedjira::Parser::GloballyUniqueIdentifier
  guid: https://cloud.google.com/blog/products/serverless/introducing-cloud-run-volume-mounts/
carlessian_info:
  news_filer_version: 2
  newspaper: Google Cloud Blog
  macro_region: Technology
rss_fields:
- title
- url
- summary
- author
- categories
- published
- entry_id
- image
image: https://storage.googleapis.com/gweb-cloudblog-publish/images/multicloud_2022_uvaqaSe.max-600x600.jpg
